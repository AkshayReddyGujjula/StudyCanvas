export type NodeStatus = "loading" | "unread" | "understood" | "struggling"

export interface HighlightEntry {
    id: string
    text: string
    nodeId: string
}

export interface ContentNodeData {
    markdown_content: string
    filename: string
    page_count: number
    pdf_id?: string
}

export interface ChatMessage {
    role: "user" | "model"
    content: string
}

export interface AnswerNodeData {
    question: string
    highlighted_text: string
    answer: string
    isLoading: boolean
    isStreaming: boolean
    status: NodeStatus
    parentResponseText?: string
    isMinimized?: boolean
    isExpanding?: boolean
    chatHistory?: ChatMessage[]
    /** Which PDF page this node belongs to (1-based) */
    pageIndex?: number
    /** If true, this node is shown on every page regardless of pageIndex */
    isPinned?: boolean
    /** Which Gemini model produced the answer */
    modelUsed?: string
}

export interface UploadResponse {
    markdown_content: string
    raw_text: string
    filename: string
    page_count: number
    pdf_id?: string
}

export interface QuizQuestion {
    question: string
    question_type: 'short_answer' | 'mcq'
    options?: string[]        // exactly 4 items when question_type === 'mcq'
    correct_option?: number   // 0-based index of correct option for MCQ
}

export interface ValidateAnswerResponse {
    status: 'correct' | 'incorrect' | 'partial'
    explanation: string
    model_used?: string
}

export interface QuizNodeInput {
    highlighted_text: string
    question: string
    answer: string
    page_index?: number
}

export interface FlashcardNodeData {
    question: string
    answer: string
    isFlipped: boolean
    status: NodeStatus
    isMinimized?: boolean
    isExpanding?: boolean
    isPinned?: boolean
    /** Which PDF page this card belongs to (1-based) */
    pageIndex?: number
    isLoading: boolean
    /** Which Gemini model produced this flashcard */
    modelUsed?: string
    /** True when this flashcard was created manually by the user (enables inline editing) */
    isCustom?: boolean
    /** True while the user is editing the currently-visible face */
    isEditing?: boolean
}

export interface QuizQuestionNodeData {
    /** 1-based page index this quiz belongs to */
    pageIndex: number
    /** 1-based question number within the page quiz */
    questionNumber: number
    /** The question text generated by Gemini */
    question: string
    /** The student's typed answer (after submission) */
    userAnswer?: string
    /** Gemini's grading feedback (after submission) */
    feedback?: string
    /** True while the grade-answer API call is in flight */
    isGrading: boolean
    /** Follow-up chat history within this quiz node */
    chatHistory?: ChatMessage[]
    /** If true, appears on all pages */
    isPinned?: boolean
    /** Self-assessment status: 'understood' | 'struggling' | 'unread' */
    status?: NodeStatus
    /** If true, only the question header is shown */
    isMinimized?: boolean
    /** Which Gemini model produced the grading feedback */
    modelUsed?: string
}

// ─── Left Toolbar Node types ─────────────────────────────────────────────────

export type PromptModel = 'gemini-2.5-flash' | 'gemini-2.5-flash-lite'

export interface CustomPromptNodeData {
    chatHistory: ChatMessage[]
    isLoading: boolean
    isStreaming: boolean
    status: NodeStatus
    isMinimized?: boolean
    isPinned?: boolean
    pageIndex?: number
    modelUsed?: string
    /** Whether to send page context (text + image) with the prompt */
    useContext: boolean
    /** Which Gemini model to use */
    selectedModel: PromptModel
}

export interface ImageNodeData {
    /** Base64 data URL of the image */
    imageDataUrl: string
    /** Original file name */
    imageName: string
    isPinned?: boolean
    pageIndex?: number
    /** Persisted width after resize */
    savedWidth?: number
    /** Persisted height after resize (0 = auto) */
    savedHeight?: number
    /** Rotation angle in degrees (0, 90, 180, 270) */
    rotation?: number
}

export interface StickyNoteNodeData {
    /** User-entered text content */
    content: string
    /** Pastel header color hex */
    color: string
    isPinned?: boolean
    pageIndex?: number
}

export const STICKY_NOTE_COLORS = [
    '#FFF9C4', // yellow
    '#FFCDD2', // pink
    '#C8E6C9', // green
    '#BBDEFB', // blue
    '#E1BEE7', // purple
    '#FFE0B2', // orange
] as const

export type TimerMode = 'pomodoro' | 'shortBreak' | 'longBreak'

export interface TimerNodeData {
    mode: TimerMode
    /** Total duration in seconds */
    duration: number
    /** Remaining seconds */
    remaining: number
    isRunning: boolean
    sessionsCompleted: number
    isPinned?: boolean
    pageIndex?: number
    /** Custom durations saved by the user (in seconds) */
    customDurations?: Record<TimerMode, number>
}

export const TIMER_DURATIONS: Record<TimerMode, number> = {
    pomodoro: 25 * 60,
    shortBreak: 5 * 60,
    longBreak: 15 * 60,
}

export interface SummaryNodeData {
    summary: string
    isLoading: boolean
    isStreaming: boolean
    status: NodeStatus
    isMinimized?: boolean
    isPinned?: boolean
    pageIndex?: number
    modelUsed?: string
    /** The page index for which this summary was generated */
    sourcePage: number
}
export interface VoiceNoteNodeData {
    /** IndexedDB key for the stored audio Blob (null before first recording) */
    audioId: string | null
    /** Duration of the recording in seconds */
    duration: number
    /** User-written label/title for the note */
    label: string
    /** Whether the node is collapsed to show only the top bar + play/pause */
    isMinimized: boolean
    isPinned?: boolean
    pageIndex?: number
    /**
     * ID of the TranscriptionNode spawned from this voice note.
     * When set, the Transcribe button is locked — user must delete the
     * TranscriptionNode first before generating a new transcription.
     */
    transcriptionNodeId?: string | null
}

export interface TranscriptionNodeData {
    /** The full transcribed text returned by Gemini */
    text: string
    /** Whether the node is collapsed to show only the header bar */
    isMinimized: boolean
    isPinned?: boolean
    pageIndex?: number
    /** Node ID of the parent VoiceNoteNode — used to clear the lock on delete */
    sourceVoiceNoteId: string
    /** Persisted width after user resize (px) */
    savedWidth?: number
    /** Persisted height after user resize (px) */
    savedHeight?: number
}
// ─── Whiteboard / Drawing types ──────────────────────────────────────────────

export type WhiteboardTool = 'cursor' | 'pen1' | 'pen2' | 'highlighter' | 'eraser' | 'text'

export type EraserMode = 'stroke' | 'area'

export interface StrokePoint {
    x: number
    y: number
    pressure?: number
}

export interface DrawingStroke {
    id: string
    points: StrokePoint[]
    color: string
    width: number
    opacity: number
    tool: 'pen1' | 'pen2' | 'highlighter'
    pageIndex: number
    timestamp: number
    /** If set, points are node-relative (offset from node's top-left in flow coords) */
    nodeId?: string
    /** The node position when the stroke was created (fallback if node is deleted) */
    nodeOffset?: { x: number; y: number }
    /** The node width (flow units) when the stroke was created — used to scale
     *  strokes proportionally when the node is resized. */
    nodeWidth?: number
    /** The Y offset from the node's top to the start of the scalable content
     *  area (header + toolbar height in flow units). Only the content below
     *  this offset scales; the offset itself stays fixed. */
    nodeContentOriginY?: number
}

export interface PenSettings {
    color: string
    width: number
}

export interface HighlighterSettings {
    color: string
    width: number
    opacity: number
}

export interface EraserSettings {
    width: number
    mode: EraserMode
}

export interface TextToolSettings {
    fontSize: number
    color: string
}

export interface ToolSettings {
    pen1: PenSettings
    pen2: PenSettings
    highlighter: HighlighterSettings
    eraser: EraserSettings
    text: TextToolSettings
}

export interface TextNodeData {
    text: string
    fontSize: number
    color: string
    pageIndex: number
    isPinned?: boolean
    width?: number
    height?: number
}

export type WhiteboardUndoAction =
    | { type: 'addStroke'; stroke: DrawingStroke }
    | { type: 'removeStroke'; stroke: DrawingStroke }
    | { type: 'removeStrokes'; strokes: DrawingStroke[] }
    | { type: 'addText'; nodeId: string }
    | { type: 'removeText'; nodeId: string; nodeSnapshot: Record<string, unknown> }

export const DEFAULT_TOOL_SETTINGS: ToolSettings = {
    pen1: { color: '#000000', width: 3 },
    pen2: { color: '#2D9CDB', width: 3 },
    highlighter: { color: '#FFE066', width: 20, opacity: 0.4 },
    eraser: { width: 20, mode: 'stroke' },
    text: { fontSize: 16, color: '#000000' },
}

export const DEFAULT_SAVED_COLORS: string[] = [
    '#000000', '#FFFFFF', '#EB5757', '#2D9CDB',
    '#27AE60', '#FFE066', '#F2994A', '#9B51E0',
]

// ─── Multi-canvas / Homepage types ───────────────────────────────────────────

/** Metadata for a single canvas entry stored in manifest.json */
export interface CanvasMeta {
    id: string
    title: string
    createdAt: string
    modifiedAt: string
    pdfFilename?: string
    pageCount?: number
    /** ID of the parent folder (null/undefined = root level) */
    parentFolderId?: string | null
}

/** Metadata for a folder entry stored in manifest.json */
export interface FolderMeta {
    id: string
    name: string
    /** ID of the parent folder (null/undefined = root level) */
    parentFolderId?: string | null
    createdAt: string
}

/** Root manifest stored in the local StudyCanvas folder */
export interface Manifest {
    version: number
    user: { name: string }
    canvases: CanvasMeta[]
    folders?: FolderMeta[]
}
